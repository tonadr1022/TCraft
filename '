#include "ChunkManager.hpp"

#include <imgui.h>

#include "application/SettingsManager.hpp"
#include "gameplay/world/BlockDB.hpp"
#include "gameplay/world/ChunkData.hpp"
#include "gameplay/world/ChunkUtil.hpp"
#include "gameplay/world/TerrainGenerator.hpp"
#include "renderer/ChunkMesher.hpp"
#include "renderer/Renderer.hpp"
#include "util/Timer.hpp"

namespace {

dp::thread_pool thread_pool(std::thread::hardware_concurrency());

}
ChunkManager::ChunkManager(BlockDB& block_db) : block_db_(block_db) {}

void ChunkManager::SetBlock(const glm::ivec3& pos, BlockType block) {
  auto chunk_pos = util::chunk::WorldToChunkPos(pos);
  auto it = chunk_map_.find(chunk_pos);
  EASSERT_MSG(it != chunk_map_.end(), "Set block in non existent chunk");
  it->second.data.SetBlock(util::chunk::WorldToPosInChunk(pos), block);
  chunk_mesh_queue_immediate_.emplace_back(chunk_pos);
  it->second.mesh_state = Chunk::State::Queued;
}

BlockType ChunkManager::GetBlock(const glm::ivec3& pos) const {
  auto it = chunk_map_.find(util::chunk::WorldToChunkPos(pos));
  EASSERT_MSG(it != chunk_map_.end(), "Get block in non existent chunk");
  return it->second.data.GetBlock(util::chunk::WorldToPosInChunk(pos));
}

void ChunkManager::Update(double /*dt*/) {
  // TODO: implement ticks

  {
    ZoneScopedN("Process chunk terrain ");
    for (const auto pos : chunk_terrain_queue_) {
      // Chunk already exists at this point so no check
      thread_pool.enqueue_detach([this, pos] {
        ZoneScopedN("chunk terrain task");
        ChunkData data;
        TerrainGenerator gen{data};
        gen.GenerateLayers(1);
        {
          std::lock_guard<std::mutex> lock(mutex_);
          finished_chunk_terrain_queue_.emplace(pos, data);
        }
      });
    }
    chunk_terrain_queue_.clear();
  }

  {
    ZoneScopedN("Process finsihed chunk terrain tasks");
    while (!finished_chunk_terrain_queue_.empty()) {
      const auto& task = finished_chunk_terrain_queue_.front();
      auto& chunk = chunk_map_.at(finished_chunk_terrain_queue_.front().first);
      chunk.data = task.second;
      chunk.terrain_state = Chunk::State::Finished;
      finished_chunk_terrain_queue_.pop();
    }
  }

  {
    ZoneScopedN("Add to mesh queue");
    constexpr static int Dx[] = {1, 0, -1, 0};
    constexpr static int Dy[] = {0, 1, 0, -1};
    int direction = 0;
    int step_radius = 1;
    int direction_steps_counter = 0;
    int turn_counter = 0;
    // TODO: use load distance
    int load_len = (5 - 1) * 2 + 1;
    glm::ivec3 pos{0, 0, 0};
    for (int i = 0; i < load_len * load_len; i++) {
      Chunk& chunk = chunk_map_.at(pos);
      if (chunk.mesh_state == Chunk::State::None && chunk.terrain_state == Chunk::State::Finished) {
        chunk_mesh_queue_.emplace_back(pos);
        chunk.mesh_state = Chunk::State::Queued;
      }
      direction_steps_counter++;
      pos.x += Dx[direction];
      pos.z += Dy[direction];
      bool change_dir = direction_steps_counter == step_radius;
      direction = (direction + change_dir) % 4;
      direction_steps_counter *= !change_dir;
      turn_counter += change_dir;
      step_radius += change_dir * (1 - (turn_counter % 2));
    }
  }
  {
    ZoneScopedN("Process remesh chunks");
    // process remesh chunks
    for (const auto pos : chunk_mesh_queue_) {
      auto& chunk = chunk_map_.at(pos);
      if (chunk.mesh.IsAllocated()) chunk.mesh.Free();
      // TODO: copy the neighbor chunks so the mesher can use them

      // Copy the data for immutability
      ChunkData data = chunk.data;
      thread_pool.enqueue_detach([this, data, pos] {
        ChunkMesher mesher{block_db_.GetBlockData(), block_db_.GetMeshData()};
        std::vector<ChunkVertex> vertices;
        std::vector<uint32_t> indices;
        mesher.GenerateNaive(data, vertices, indices);
        {
          std::lock_guard<std::mutex> lock(mutex_);
          chunk_mesh_finished_queue_.emplace(vertices, indices, pos);
        }
      });
    }
    chunk_mesh_queue_.clear();
  }

  {
    ZoneScopedN("Process finished mesh chunks");
    Timer timer;
    while (!chunk_mesh_finished_queue_.empty()) {
      if (timer.ElapsedMS() > 3) break;
      auto& task = chunk_mesh_finished_queue_.front();
      total_vertex_count_ += task.vertices.size();
      total_index_count_ += task.indices.size();
      num_mesh_creations_++;
      auto& chunk = chunk_map_.at(chunk_mesh_finished_queue_.front().pos);
      chunk.mesh.Allocate(task.vertices, task.indices);
      chunk.mesh_state = Chunk::State::Finished;
      chunk_mesh_finished_queue_.pop();
    }
  }

  {
    ZoneScopedN("Immediate chunk remesh");
    for (const auto& pos : chunk_mesh_queue_immediate_) {
      auto& chunk = chunk_map_.at(pos);
      if (chunk.mesh.IsAllocated()) chunk.mesh.Free();
      std::vector<ChunkVertex> vertices;
      std::vector<uint32_t> indices;
      ChunkMesher mesher{block_db_.GetBlockData(), block_db_.GetMeshData()};
      mesher.GenerateNaive(chunk.data, vertices, indices);
      total_vertex_count_ += vertices.size();
      total_index_count_ += indices.size();
      num_mesh_creations_++;
      chunk.mesh.Allocate(vertices, indices);
      chunk.mesh_state = Chunk::State::Finished;
    }
    chunk_mesh_queue_immediate_.clear();
  }
}

void ChunkManager::Init() {
  auto settings = SettingsManager::Get().LoadSetting("chunk_manager");
  load_distance_ = settings.value("load_distance", 16);
  // Spiral iteration from 0,0

  // gather vector of blocks
  std::vector<BlockType> blocks;
  const auto& block_data = block_db_.GetBlockData();
  blocks.reserve(block_data.size());
  for (size_t i = 1; i < block_data.size(); i++) {
    blocks.emplace_back(i);
  }

  constexpr static int Dx[] = {1, 0, -1, 0};
  constexpr static int Dy[] = {0, 1, 0, -1};
  int direction = 0;
  int step_radius = 1;
  int direction_steps_counter = 0;
  int turn_counter = 0;
  int load_len = 5 * 2 + 1;
  // int load_len = load_distance_ * 2 + 1;
  glm::ivec3 pos{0, 0, 0};
  for (int i = 0; i < load_len * load_len; i++) {
    // for (int i = 0; i < 5; i++) {
    //   pos.y = i;
    chunk_map_.try_emplace(pos, pos);
    chunk_terrain_queue_.emplace_back(pos);
    chunk_map_.at(pos).terrain_state = Chunk::State::Queued;
    // }
    direction_steps_counter++;
    pos.x += Dx[direction];
    pos.z += Dy[direction];
    bool change_dir = direction_steps_counter == step_radius;
    direction = (direction + change_dir) % 4;
    direction_steps_counter *= !change_dir;
    turn_counter += change_dir;
    step_radius += change_dir * (1 - (turn_counter % 2));
  }
}

ChunkManager::~ChunkManager() {
  nlohmann::json j = {{"load_distance", load_distance_}};
  SettingsManager::Get().SaveSetting(j, "chunk_manager");
}

void ChunkManager::OnImGui() {
  if (ImGui::CollapsingHeader("Chunk Manager", ImGuiTreeNodeFlags_DefaultOpen)) {
    ImGui::SliderInt("Load Distance", &load_distance_, 1, 32);
    if (num_mesh_creations_ > 0) {
      ImGui::Text("Avg vertices: %i", total_vertex_count_ / num_mesh_creations_);
      ImGui::Text("Avg indices: %i", total_index_count_ / num_mesh_creations_);
      ImGui::Text("Total vertices: %i", total_vertex_count_);
      ImGui::Text("Total indices: %i", total_index_count_);
    }
  }
}

bool ChunkManager::BlockPosExists(const glm::ivec3& world_pos) const {
  return chunk_map_.contains(util::chunk::WorldToChunkPos(world_pos));
}

// void ChunkManager::PopulateChunkNeighborDataArray(ChunkData* chunk_data[27],
//                                                   std::vector<BlockType>& block_data) {
//   EASSERT_MSG(block_data.size() == MeshChunkVolume,
//               "Invalid block data size for neighbor population");
//   int chunk_z;
//   int chunk_x;
//   int chunk_y;
//
//   // chunks at same level as middle chunk
//   for (chunk_y = 0; chunk_y < ChunkLength; chunk_y++) {
//   }
// }
